#!/usr/bin/env python3
"""
Realtime plotter for GRPO training metrics.

Run this script alongside `train_grpo.py` to visualize the metrics that are
streamed into the CSV produced by `MetricsTracker`. The plot refreshes at a
configurable interval and updates as new rows are appended to the CSV.
"""

from __future__ import annotations

import argparse
import time
from pathlib import Path
from typing import Iterable

import matplotlib.pyplot as plt
import pandas as pd


METRIC_COLUMNS = [
    ("parse_rate", "Parse Rate", (0.0, 1.05)),
    ("acc_opt", "Optimal Action Accuracy", (0.0, 1.05)),
    ("mean_regret", "Mean Regret", None),
    ("mean_reward", "Mean Reward", None),
]


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Watch GRPO training metrics in realtime.")
    parser.add_argument(
        "--metrics-csv",
        type=Path,
        default=Path("metrics.csv"),
        help="Path to the metrics CSV generated by train_grpo.py.",
    )
    parser.add_argument(
        "--refresh-sec",
        type=float,
        default=2.0,
        help="Refresh interval in seconds.",
    )
    parser.add_argument(
        "--max-points",
        type=int,
        default=None,
        help="If set, limit the plotted history to the most recent N points.",
    )
    return parser.parse_args()


def _load_metrics(path: Path, max_points: int | None) -> pd.DataFrame:
    df = pd.read_csv(path)
    if max_points is not None and max_points > 0:
        df = df.iloc[-max_points:]
    return df


def _init_axes() -> tuple[plt.Figure, list[plt.Axes]]:
    fig, axes = plt.subplots(2, 2, figsize=(12, 8), constrained_layout=True)
    flat_axes = axes.flatten()
    for ax, (_, title, y_limits) in zip(flat_axes, METRIC_COLUMNS):
        ax.set_title(title)
        ax.set_xlabel("global_step")
        ax.grid(True, linestyle="--", linewidth=0.5, alpha=0.6)
        if y_limits:
            ax.set_ylim(*y_limits)
    return fig, flat_axes.tolist()


def _update_lines(
    axes: Iterable[plt.Axes],
    df: pd.DataFrame,
    lines: list[plt.Line2D],
) -> None:
    x = df["global_step"]
    for ax, (column, _, y_limits), line in zip(axes, METRIC_COLUMNS, lines):
        if column not in df.columns:
            line.set_data([], [])
            ax.set_xlim(0, 1)
            continue
        y = df[column]
        line.set_data(x, y)
        ax.relim()
        ax.autoscale_view(scalex=True, scaley=(y_limits is None))


def main() -> None:
    args = parse_args()
    metrics_path = args.metrics_csv
    refresh = max(args.refresh_sec, 0.1)

    if not metrics_path.exists():
        print(f"[info] Waiting for metrics file {metrics_path} to appear...")
        while not metrics_path.exists():
            time.sleep(refresh)

    fig, axes = _init_axes()
    lines: list[plt.Line2D] = []
    for ax, (column, _, _) in zip(axes, METRIC_COLUMNS):
        (line,) = ax.plot([], [], label=column)
        ax.legend(loc="upper right")
        lines.append(line)

    plt.show(block=False)

    last_mtime = None
    try:
        while plt.fignum_exists(fig.number):
            try:
                stat = metrics_path.stat()
            except FileNotFoundError:
                time.sleep(refresh)
                continue

            if last_mtime is None or stat.st_mtime_ns != last_mtime:
                last_mtime = stat.st_mtime_ns
                df = _load_metrics(metrics_path, args.max_points)
                if not df.empty:
                    _update_lines(axes, df, lines)
                    fig.canvas.draw_idle()
                    fig.canvas.flush_events()

            time.sleep(refresh)
    except KeyboardInterrupt:
        pass


if __name__ == "__main__":
    main()
